package main

const wdbTpl = `// Code generated by wpb. DO NOT EDIT.{{$tbl := .}}
package {{$tbl.DB}}

$Import-Packages$

////////////////////////////////////////////////////////////////////////////////
// public interface {{ $key := $tbl.PrimaryKey }} {{ $ksize := len $key }}

{{if $tbl.PrimaryKey }} 
  {{- if eq $ksize 1 }} {{$col := index $tbl.PrimaryKey 0}}
type {{Title $tbl.Name}}Key = {{$col.GoType}}
  {{- else -}}
type {{Title $tbl.Name}}Key struct { {{ range $i,$col := $key }}
	{{Doc $col.Doc}} {{Title $col.Name}} {{$col.GoType}} {{ end -}}
}
  {{- end }}
{{- end }}

type {{Title $tbl.Name}}Operation interface {
	Insert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error)
	InsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) 

{{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	Update(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error){{end}}{{if $tbl.GenUpsert }} 
	Upsert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) 
	UpsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error){{end}}
{{end}}

{{if $tbl.PrimaryKey}}
	Find(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindEx(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}Ex, err error){{end}}
	Delete(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (res sql.Result, err error)

	FindByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (data *{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (data *{{Title $tbl.Struct}}Ex, err error){{end}}
	DeleteByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (res sql.Result, err error)

	FindByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}
	DeleteByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (res sql.Result, err error)
{{end}}


{{- range $i,$idx := $tbl.Index }}
	FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}limit,offset int) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}limit,offset int) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}
	CountByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (count int, err error) 
	DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error) 
{{end}}

	Where(bufSize int) *{{Title $tbl.Name}}WhereStmt 
	Select(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	SelectEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}Ex, err error) {{end}}
	Count(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (count int, err error)

	DeleteMany(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (res sql.Result, err error) 

	RangeAll(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt, f func(ctx context.Context, row *{{Title $tbl.Struct}}) bool) error{{ if $tbl.GenEx }}
	RangeAllEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt, f func(ctx context.Context, row *{{Title $tbl.Struct}}Ex) bool) error {{end}}
	AllData(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	AllDataEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}

	// use for custom named sql 
	DB() *sqlx.DB
}

var ({{range $i,$col := $tbl.AllColumns false}} {{if $col.Unmarshal }}
	{{Title $tbl.Name}}{{Title $col.Name}}Unamrshal = {{$tbl.SvcDB}}.RawTo{{$col.Unmarshal}} {{ end }} {{end}}
{{range $i,$col := $tbl.AllColumns false }} {{if $col.Marshal }}
	{{Title $tbl.Name}}{{Title $col.Name}}Marshal = {{$tbl.SvcDB}}.AnyFrom{{$col.Marshal}} {{ end }} {{end}}
)

var (
	global{{Title .Name}}OP atomic.Pointer[x{{Title $tbl.Name}}Operation]
)

func init() {
	{{$tbl.SvcDB}}.RegisterSyncDBTable("mysql", "{{$tbl.DB}}", "{{$tbl.SqlTable}}", Sync{{Title $tbl.Name}}DBTable)
	{{$tbl.SvcDB}}.RegisterDB("mysql", "{{$tbl.DB}}", "{{$tbl.SqlTable}}", func(db *sqlx.DB) error {
		//
		err := Sync{{Title $tbl.Name}}DBTable(context.Background(), db)
		if err != nil {
			return fmt.Errorf("swap {{$tbl.DB}}.{{$tbl.SqlTable}} pointer, %w", err)
		}
		//
		tableOP, err := New{{Title $tbl.Name}}Operation(db)
		if err != nil {
			return fmt.Errorf("swap {{$tbl.DB}}.{{$tbl.SqlTable}} pointer, new table operation failed, %w", err)
		}

		global{{Title $tbl.Name}}OP.Store(tableOP)
		return nil
	})
}

var {{Title $tbl.Name}}OP = func() {{Title $tbl.Name}}Operation {
	return global{{Title .Name}}OP.Load()
}

func {{Title $tbl.Name}}NamedSQL(bufSize int)  *{{Title $tbl.Name}}SQLWriter{
	sql := &{{Title $tbl.Name}}SQLWriter{}
	sql.buf.Grow(bufSize)
	return sql
}


func Sync{{Title $tbl.Name}}DBTable(ctx context.Context, db *sqlx.DB) (err error) {
	// sync table columns
	err = {{$tbl.SvcDB}}.SyncTableColumns(context.Background(), db, "{{$tbl.SqlTable}}", {{Title $tbl.Name}}SQL_Create, {{Title $tbl.Name}}SQL_TableColumns)
	if err != nil {
		return fmt.Errorf("sync {{$tbl.DB}}.{{$tbl.SqlTable}} table, sync columns failed, %w", err)
	}{{if $tbl.Index }} 
	// sync table index
	err = {{$tbl.SvcDB}}.SyncTableIndex(context.Background(), db, "{{$tbl.SqlTable}}", {{Title $tbl.Name}}SQL_TableIndex)
	if err != nil {
		return fmt.Errorf("sync {{$tbl.DB}}.{{$tbl.SqlTable}} table, sync index failed, %w", err)
	}{{end}}
	return
}

{{if $tbl.PrimaryKey }} 
func {{Title $tbl.Name}}ToPrimaryKeys(rows []*{{Title $tbl.Struct}}) (ids []{{Title $tbl.Name}}Key) {
	ids = make([]{{Title $tbl.Name}}Key, 0, len(rows))
	for _, v := range rows { {{- if eq $ksize 1 }} {{ $id := index $key 0 }}
		ids = append(ids, v.{{Title $id.Name }}) {{else}}
		ids = append(ids, {{Title $tbl.Name}}Key { {{ range $i,$col := $key }}
			{{Title $col.Name}}:v.{{Title $col.Name}} ,{{ end }}
		}) {{ end }}
	}
	return
}
{{ if $tbl.GenEx }}
func {{Title $tbl.Name}}ExToPrimaryKeysEx(rows []*{{Title $tbl.Struct}}Ex) (ids []{{Title $tbl.Name}}Key) {
	ids = make([]{{Title $tbl.Name}}Key, 0, len(rows))
	for _, v := range rows { {{- if eq $ksize 1 }} {{ $id := index $key 0 }}
		ids = append(ids, v.{{Title $id.Name }}) {{else}}
		ids = append(ids, {{Title $tbl.Name}}Key { {{ range $i,$col := $key }}
			{{Title $col.Name}}:v.{{Title $col.Name}}, {{ end }}
		}) {{ end }}
	}
	return
}{{end}}
{{end}}

////////////////////////////////////////////////////////////////////////////////
// sql statement

const (
	{{Title $tbl.Name}}SQL_Insert        = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder true}})"{{ if $tbl.AutoIncr}}
	{{Title $tbl.Name}}SQL_Insert2       = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder false}})"{{end}}
	{{Title $tbl.Name}}SQL_InsertValues  = ",({{$tbl.Placeholder true}})"
	{{Title $tbl.Name}}SQL_InsertValues2 = ",({{$tbl.Placeholder false}})" {{if $tbl.PrimaryKey}}
	{{Title $tbl.Name}}SQL_Where1        = " where ({{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}})"
	{{Title $tbl.Name}}SQL_Where2        = " or ({{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}})"
	{{Title $tbl.Name}}SQL_Upsert        = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder false}})"
	{{Title $tbl.Name}}SQL_UpsertUpdate  = " on duplicate key update {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{$col.SqlName}}=values({{$col.SqlName}}){{end}}"
	{{Title $tbl.Name}}SQL_Update        = "update {{$tbl.SqlTable}} set {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{$col.SqlName}}=?{{end}} where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}" {{end}}
	{{Title $tbl.Name}}SQL_Delete        = "delete from {{$tbl.SqlTable}}"
	{{Title $tbl.Name}}SQL_Find          = "select {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}} from {{$tbl.SqlTable}}"{{ if $tbl.GenEx }}
	{{Title $tbl.Name}}SQL_FindRow       = "select {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}},{{BackQuote "modify_stamp"}},{{BackQuote "create_stamp"}} from {{$tbl.SqlTable}}"{{end}}
	{{Title $tbl.Name}}SQL_Count         = "select count(*) from {{$tbl.SqlTable}}"
	{{Title $tbl.Name}}SQL_Create        = "create table {{$tbl.SqlTable}} ("+ {{range $i,$col :=  $tbl.AllColumns false}}
		"{{Comma $i}}{{$col.SqlName}} {{$col.SqlType}}" + {{end}} {{ if $tbl.GenEx }}
		",{{BackQuote "modify_stamp"}} timestamp default current_timestamp on update current_timestamp" +
		",{{BackQuote "create_stamp"}} timestamp default current_timestamp" + {{end}} {{if $tbl.PrimaryKey }}
		",PRIMARY KEY ( {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.SqlName}}{{end}})" + {{end}}
		") ENGINE={{$tbl.Engine}} DEFAULT CHARSET={{$tbl.Charset}} COLLATE={{$tbl.Collate}};"
)

var (
	{{Title $tbl.Name}}SQL_TableColumns = map[string]string{ {{- range $i,$col :=  $tbl.AllColumns false}}
		"{{$col.Name}}": "alter table {{$tbl.SqlTable}} add {{$col.SqlName}} {{$col.SqlType}};",{{end}}
	}{{if $tbl.Index }} 
	{{Title $tbl.Name}}SQL_TableIndex = map[string]string{ {{- range $i,$idx := $tbl.Index }}
		"{{$tbl.SqlTable}}_{{$idx.Name}}": "create {{$idx.Unique}}index {{$tbl.SqlTable}}_{{$idx.Name}} on {{$tbl.SqlTable}}({{range $i,$col := $idx.Columns}}{{Comma $i}}{{$col.SqlName}}{{end}})", {{end}}
	}{{end}}
)

////////////////////////////////////////////////////////////////////////////////
// TblTestOperation impl

type x{{Title $tbl.Name}}Operation struct {
	db      *sqlx.DB
	insert  *sql.Stmt{{ if $tbl.AutoIncr}}
	insert2 *sql.Stmt // increment id {{end}} {{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	update  *sql.Stmt{{end}}{{if $tbl.GenUpsert }}
	upsert  *sql.Stmt{{end}}
	delete  *sql.Stmt
	find    *sql.Stmt {{ if $tbl.GenEx }}
	findRow *sql.Stmt {{end}} {{end}} {{- range $i,$idx := $tbl.Index }}
	idx{{Title $idx.Name}}Find *sql.Stmt{{ if $tbl.GenEx }}
	idx{{Title $idx.Name}}FindEx *sql.Stmt{{end}}
	idx{{Title $idx.Name}}Count *sql.Stmt
	idx{{Title $idx.Name}}Delete *sql.Stmt{{end}}
}

func New{{Title $tbl.Name}}Operation(db *sqlx.DB) (_ *x{{Title $tbl.Name}}Operation, err error) {
	t := &x{{Title $tbl.Name}}Operation{
		db: db,
	}

	t.insert, err = db.Prepare({{Title $tbl.Name}}SQL_Insert)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} insert failed,%w", err)
	}{{ if $tbl.AutoIncr}}
	t.insert2, err = db.Prepare({{Title $tbl.Name}}SQL_Insert2)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} insert2 failed,%w", err)
	}{{end}} {{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	t.update, err = db.Prepare({{Title $tbl.Name}}SQL_Update)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} update failed,%w", err)
	}{{end}}{{if $tbl.GenUpsert }}
	t.upsert, err = db.Prepare({{Title $tbl.Name}}SQL_Upsert + {{Title $tbl.Name}}SQL_UpsertUpdate)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} upsert failed,%w", err)
	}{{end}}
	t.delete, err = db.Prepare({{Title $tbl.Name}}SQL_Delete + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}")
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} delete failed,%w", err)
	}
	t.find, err = db.Prepare({{Title $tbl.Name}}SQL_Find + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}")
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find failed,%w", err)
	}{{ if $tbl.GenEx }}
	t.findRow, err = db.Prepare({{Title $tbl.Name}}SQL_FindRow + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}")
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex failed,%w", err)
	}{{end}} {{end}}

	return t, nil
}

func (t *x{{Title $tbl.Name}}Operation) Insert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} != 0 {
		res, err = t.insert2.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	} else {
		res, err = t.insert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}{{else}}
	res, err = t.insert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}) {{end}}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) InsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.Insert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	withID := datas[0].{{Title $tbl.AutoIncr.Name}} != 0
	// 必须都设置了 incr id 或者都没有设置 incr.
	for i := 1; i < len(datas); i++ {
		if withID != (datas[i].{{Title $tbl.AutoIncr.Name}} != 0) {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} check failed, auto increment field not match. frist:%t %d:%t", withID, i, !withID)
		}
	}
	if withID {
		buf := util.Builder{}
		buf.Grow(len({{Title $tbl.Name}}SQL_Insert2) + (len(datas)-1)*len({{Title $tbl.Name}}SQL_InsertValues2))
		buf.Write([]byte({{Title $tbl.Name}}SQL_Insert2))
		for i := 0; i < len(datas)-1; i++ {
			buf.Write([]byte({{Title $tbl.Name}}SQL_InsertValues2))
		}
		args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns false}}{{len $all}})
		for i := 0; i < len(datas); i++ {
			data := datas[i]
			args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		}
		res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many withid failed,%w", err)
		}
		return
	}
{{end}}
	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_Insert) + (len(datas)-1)*len({{Title $tbl.Name}}SQL_InsertValues))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{Title $tbl.Name}}SQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns true}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many failed,%w", err)
	}
	return
}

{{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
func (t *x{{Title $tbl.Name}}Operation) Update(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{- if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return nil, errors.New("update {{$tbl.SqlTable}} not set primary key")
	}{{end}}
	res, err = t.update.ExecContext(ctx, {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}data.{{Title $col.Name}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} update failed,%w", err)
	}

	return
}

{{end}}{{if $tbl.GenUpsert }}
func (t *x{{Title $tbl.Name}}Operation) Upsert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return t.Insert(ctx, data)
	}{{end}}

	res, err = t.upsert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) UpsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.Upsert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	for i := 1; i < len(datas); i++ {
		if datas[i].{{Title $tbl.AutoIncr.Name}} == 0 {
			return nil, errors.New("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many check not set incr id")
		}
	}{{end}}

	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_Upsert) + (len(datas)-1)*len({{Title $tbl.Name}}SQL_InsertValues2) + len({{Title $tbl.Name}}SQL_UpsertUpdate))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Upsert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{Title $tbl.Name}}SQL_InsertValues2))
	}
	buf.Write([]byte({{Title $tbl.Name}}SQL_UpsertUpdate))
	args := make([]any, 0, len(datas)* {{$all := $tbl.AllColumns false}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many failed,%w", err)
	}
	return
}
{{end}}
{{end}}

{{if $tbl.PrimaryKey}}
// find by primary key
func (t *x{{Title $tbl.Name}}Operation) Find(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	rows, err := t.find.QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scan{{Title $tbl.Name}}(rows)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindEx(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scan{{Title $tbl.Name}}Ex(rows)
	}
	return
}
{{end}}
func (t *x{{Title $tbl.Name}}Operation) Delete(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete failed,%w", err)
	}

	return
}

// find by primary key
func (t *x{{Title $tbl.Name}}Operation) FindByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (data *{{Title $tbl.Struct}}, err error) {
	rows, err := t.find.QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return scan{{Title $tbl.Name}}(rows)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (data *{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key failed,%w", err)
	}
	defer rows.Close()
	data = &{{Title $tbl.Struct}}Ex{}
	for rows.Next() {
		return scan{{Title $tbl.Name}}Ex(rows)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DeleteByKey(ctx context.Context, id {{Title $tbl.Name}}Key) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (t *x{{Title $tbl.Name}}Operation) FindByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (datas []*{{Title $tbl.Struct}}, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}{data}, nil 
	}
	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_Find) + len({{Title $tbl.Name}}SQL_Where1)+ (len(ids)-1)*len({{Title $tbl.Name}}SQL_Where2))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Find))	
	buf.Write([]byte({{Title $tbl.Name}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{Title $tbl.Name}}SQL_Where2))
	}
	
	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindExByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}Ex{data}, nil 
	}
	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_FindRow) + len({{Title $tbl.Name}}SQL_Where1)+ (len(ids)-1)*len({{Title $tbl.Name}}SQL_Where2))
	buf.Write([]byte({{Title $tbl.Name}}SQL_FindRow))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{Title $tbl.Name}}SQL_Where2))
	}
	
	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DeleteByKeyArray(ctx context.Context, ids []{{Title $tbl.Name}}Key) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.DeleteByKey(ctx, ids[0]) 
	}
	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_Delete) + len({{Title $tbl.Name}}SQL_Where1)+ (len(ids)-1)*len({{Title $tbl.Name}}SQL_Where2))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Delete))	
	buf.Write([]byte({{Title $tbl.Name}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{Title $tbl.Name}}SQL_Where2))
	}
	
	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key_array failed,%w", err)
	}
	return
}

{{end}}

{{- range $i,$idx := $tbl.Index }}
func (t *x{{Title $tbl.Name}}Operation) FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}, err error) {
	if t.idx{{Title $idx.Name}}Find == nil {
		t.idx{{Title $idx.Name}}Find, err = t.db.PrepareContext(ctx, {{Title $tbl.Name}}SQL_Find + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}Find.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	if t.idx{{Title $idx.Name}}FindEx == nil {
		t.idx{{Title $idx.Name}}FindEx, err = t.db.PrepareContext(ctx, {{Title $tbl.Name}}SQL_FindRow + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}FindEx.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}{{end}}

func (t *x{{Title $tbl.Name}}Operation) CountByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (count int, err error) {
	if t.idx{{Title $idx.Name}}Count == nil {
		t.idx{{Title $idx.Name}}Count, err = t.db.PrepareContext(ctx, {{Title $tbl.Name}}SQL_Count + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}}")
		if err != nil {
			return 0, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	err = t.idx{{Title $idx.Name}}Count.QueryRowContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}

func (t *x{{Title $tbl.Name}}Operation) DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error) {
if t.idx{{Title $idx.Name}}Delete == nil {
		t.idx{{Title $idx.Name}}Delete, err = t.db.PrepareContext(ctx, {{Title $tbl.Name}}SQL_Delete + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}}")
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} delete_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	res, err = t.idx{{Title $idx.Name}}Delete.ExecContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{Title $tbl.Name}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}
{{end}}
func (t *x{{Title $tbl.Name}}Operation) Where(bufSize int) *{{Title $tbl.Name}}WhereStmt {
	w := &{{Title $tbl.Name}}WhereStmt{}
	w.buf.Grow(bufSize)
	w.buf.Write([]byte(" where "))
	return w
}

func (t *x{{Title $tbl.Name}}Operation) Select(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}, err error) {
	var findSql = {{Title $tbl.Name}}SQL_Find
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := scan{{Title $tbl.Name}}(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) SelectEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	var findSql = {{Title $tbl.Name}}SQL_FindRow
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} selectex failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) Count(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (count int, err error) {
	var findSql = {{Title $tbl.Name}}SQL_Count
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	err = t.db.QueryRowContext(ctx, findSql).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count failed,%w", err)
	}
	return
}

func (t *x{{Title $tbl.Name}}Operation) DeleteMany(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (res sql.Result, err error) {
	var w  string 
	if where != nil {
		w = where.String()
	}
	buf := util.Builder{}
	buf.Grow(len({{Title $tbl.Name}}SQL_Delete) + len(w))
	buf.Write([]byte({{Title $tbl.Name}}SQL_Delete))
	buf.WriteString(w)
	res, err = t.db.ExecContext(ctx, buf.String())
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_many failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) RangeAll(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt, f func(ctx context.Context, row *{{Title $tbl.Struct}}) bool) error {
	var findSql = {{Title $tbl.Name}}SQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scan{{Title $tbl.Name}}(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) RangeAllEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt, f func(ctx context.Context, row *{{Title $tbl.Struct}}Ex) bool) error {
	var findSql = {{Title $tbl.Name}}SQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scan{{Title $tbl.Name}}Ex(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) AllData(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}, err error) {
	var findSql = {{Title $tbl.Name}}SQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*{{Title $tbl.Struct}}, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scan{{Title $tbl.Name}}(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) AllDataEx(ctx context.Context, where *{{Title $tbl.Name}}WhereStmt) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	var findSql = {{Title $tbl.Name}}SQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*{{Title $tbl.Struct}}Ex, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data_ex failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scan{{Title $tbl.Name}}Ex(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DB() *sqlx.DB {
	return t.db
}

////////////////////////////////////////////////////////////////////////////////
// where stmt

type {{Title $tbl.Name}}WhereStmt struct {
	buf           util.Builder
	limit, offset int
}
{{range $i,$col := $tbl.AllColumns false}}
func (w *{{Title $tbl.Name}}WhereStmt) {{Title $col.Name}}() *{{$tbl.SvcDB}}.{{$col.Cond $tbl.Name}} {
	return {{$tbl.SvcDB}}.New{{$col.Cond $tbl.Name}} (w, &w.buf, "{{$col.Name}}")
}
{{end}}

func (w *{{Title $tbl.Name}}WhereStmt) Limit(limit, offset int) *{{Title $tbl.Name}}WhereStmt {
	w.limit = limit
	w.offset = offset
	return w
}

func (w *{{Title $tbl.Name}}WhereStmt) And() *{{Title $tbl.Name}}WhereStmt {
	w.buf.Write([]byte(" and "))
	return w
}

func (w *{{Title $tbl.Name}}WhereStmt) Or() *{{Title $tbl.Name}}WhereStmt {
	w.buf.Write([]byte(" or "))
	return w
}

func (w *{{Title $tbl.Name}}WhereStmt) Group(gf func(w *{{Title $tbl.Name}}WhereStmt)) *{{Title $tbl.Name}}WhereStmt {
	w.buf.WriteByte('(')
	gf(w)
	w.buf.WriteByte(')')
	return w
}


func (w *{{Title $tbl.Name}}WhereStmt) Custom(f func(buf *util.Builder)) *{{Title $tbl.Name}}WhereStmt {
	f(&w.buf)
	return w
}

func (w *{{Title $tbl.Name}}WhereStmt) applyLimitAndOffset() {
	if w.limit == 0 && w.offset == 0 {
		return
	}
	w.buf.Write([]byte(" limit "))
	w.buf.WriteInt(w.offset)
	w.buf.WriteByte(',')
	w.buf.WriteInt(w.limit)
}

func (w *{{Title $tbl.Name}}WhereStmt) String() string {
	return w.buf.String()
}

////////////////////////////////////////////////////////////////////////////////
// scan interface {{$all := $tbl.AllColumns false}}

func scan{{Title $tbl.Name}}(rows *sql.Rows) (data *{{Title $tbl.Struct}}, err error) {
	var values [{{len $all}}]sql.RawBytes
	err = rows.Scan({{range $i,$col := $tbl.AllColumns false}} &values[{{$i}}],{{end}})
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan failed, %w", err)
	}

	data = &{{Title $tbl.Struct}}{} {{range $i,$col := $tbl.AllColumns false}} 
	data.{{Title $col.Name}}, err = {{Title $tbl.Name}}{{Title $col.Name}}Unamrshal(values[{{$i}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan {{$col.Name}} failed, %w", err)
	}{{end}}
	return data, nil 
}
{{ if $tbl.GenEx }}
func scan{{Title $tbl.Name}}Ex(rows *sql.Rows) (data *{{Title $tbl.Struct}}Ex, err error) { 
	var values [{{len $all}}+2]sql.RawBytes
	err = rows.Scan({{range $i,$col := $tbl.AllColumns false}}&values[{{$i}}],{{end}}&values[{{len $all}}],&values[{{len $all}}+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex failed, %w", err)
	}

	data = &{{Title $tbl.Struct}}Ex{} {{range $i,$col := $tbl.AllColumns false}} 
	data.{{Title $col.Name}}, err = {{Title $tbl.Name}}{{Title $col.Name}}Unamrshal(values[{{$i}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex {{$col.Name}} failed, %w", err)
	}{{end}}  
	data.ModifyStamp,err = svc_db.RawToStampInt64(values[{{len $all}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex modify_stamp failed, %w", err)
	}
	data.CreateStamp,err = svc_db.RawToStampInt64(values[{{len $all}}+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex create_stamp failed, %w", err)
	}
	return data, nil
}
{{end}}

////////////////////////////////////////////////////////////////////////////////
// named sql

type {{Title $tbl.Name}}SQLWriter struct {
	buf util.Builder
}

func (x *{{Title $tbl.Name}}SQLWriter) Select() *{{Title $tbl.Name}}NamedSelect {
	x.buf.Write([]byte("select "))
	var v int
	return &{{Title $tbl.Name}}NamedSelect{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *{{Title $tbl.Name}}SQLWriter) Update() *{{Title $tbl.Name}}NamedUpdate {
	x.buf.Write([]byte("update {{$tbl.SqlTable}} set "))
	var v int
	return &{{Title $tbl.Name}}NamedUpdate{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *{{Title $tbl.Name}}SQLWriter) Insert() *{{Title $tbl.Name}}NamedInsert {
	return &{{Title $tbl.Name}}NamedInsert{
		buf: &x.buf,
	}
}

func (x *{{Title $tbl.Name}}SQLWriter) Delete() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte("delete from {{$tbl.SqlTable}} where "))
	return &{{Title $tbl.Name}}NamedWhere{
		buf: &x.buf,
	}
}

type {{Title $tbl.Name}}NamedInsert struct {
	buf  *util.Builder
	list,values []string
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *{{Title $tbl.Name}}NamedInsert) {{Title $col.Name}}() *{{Title $tbl.Name}}NamedInsert {
	x.list = append(x.list, "{{$col.SqlName}}")
	x.values = append(x.values, ":{{$col.Name}}")
	return x
}
{{end}}
{{ if $tbl.GenEx }}
func (x *{{Title $tbl.Name}}NamedInsert) ModifyStamp() *{{Title $tbl.Name}}NamedInsert {
	x.list = append(x.list, "{{BackQuote "modify_stamp"}}")
	x.values = append(x.values, ":modify_stamp")
	return x
}

func (x *{{Title $tbl.Name}}NamedInsert) CreateStamp() *{{Title $tbl.Name}}NamedInsert {
	x.list = append(x.list, "{{BackQuote "create_stamp"}}")
	x.values = append(x.values, ":create_stamp")
	return x
}
{{end}}

func (x *{{Title $tbl.Name}}NamedInsert) ToSQL() string {
	x.buf.Write([]byte("insert {{$tbl.SqlTable}}("))
	x.buf.WriteString(strings.Join(x.list, ","))
	x.buf.Write([]byte(") values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

func (x *{{Title $tbl.Name}}NamedInsert) ValuesToSQL() string {
	x.buf.Write([]byte(",values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

type {{Title $tbl.Name}}NamedUpdate struct {
	buf *util.Builder
	n   *int
	values *bool
}

{{range $i,$col := $tbl.AllColumns false}}
func (x *{{Title $tbl.Name}}NamedUpdate) {{Title $col.Name}}() *{{Title $tbl.Name}}NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{$col.SqlName}}=values({{$col.SqlName}})"))
	} else {
		x.buf.Write([]byte("{{$col.SqlName}}=:{{$col.Name}}"))
	}
	*x.n++
	return x
}
{{end}}
{{ if $tbl.GenEx }}
func (x *{{Title $tbl.Name}}NamedUpdate) ModifyStamp() *{{Title $tbl.Name}}NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{BackQuote "modify_stamp"}}=values({{BackQuote "modify_stamp"}})"))
	}else {
		x.buf.Write([]byte("{{BackQuote "modify_stamp"}}=:modify_stamp"))
	}
	*x.n++
	return x
}

func (x *{{Title $tbl.Name}}NamedUpdate) CreateStamp() *{{Title $tbl.Name}}NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{BackQuote "create_stamp"}}=values({{BackQuote "create_stamp"}})"))
	}else {
		x.buf.Write([]byte("{{BackQuote "create_stamp"}}=:create_stamp"))
	}
	*x.n++
	return x
}
{{end}}

func (x *{{Title $tbl.Name}}NamedUpdate) Where() *{{Title $tbl.Name}}NamedWhere {
	if x.values != nil {
		panic("invalid where")
	}
	x.buf.Write([]byte(" where "))
	return &{{Title $tbl.Name}}NamedWhere{
		buf: x.buf,
	}
}

func (x *{{Title $tbl.Name}}NamedUpdate) ToSQL() string {
	return x.buf.String()
}

type {{Title $tbl.Name}}NamedSelect struct {
	buf *util.Builder
	n   *int
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *{{Title $tbl.Name}}NamedSelect) {{Title $col.Name}}() *{{Title $tbl.Name}}NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{$col.SqlName}}"))
	*x.n++
	return x
}
{{end}}

{{ if $tbl.GenEx }}
func (x *{{Title $tbl.Name}}NamedSelect) ModifyStamp() *{{Title $tbl.Name}}NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}}"))
	*x.n++
	return x
}

func (x *{{Title $tbl.Name}}NamedSelect) CreateStamp() *{{Title $tbl.Name}}NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "create_stamp"}}"))
	*x.n++
	return x
}{{end}}

func (x *{{Title $tbl.Name}}NamedSelect) Where() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte(" from {{$tbl.SqlTable}} where "))
	return &{{Title $tbl.Name}}NamedWhere{
		buf: x.buf,
	}
}


func (x *{{Title $tbl.Name}}NamedSelect) ToSQL() string {
	x.buf.Write([]byte(" from {{$tbl.SqlTable}}"))
	return x.buf.String()
}

type {{Title $tbl.Name}}NamedWhere struct {
	buf *util.Builder
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *{{Title $tbl.Name}}NamedWhere) {{Title $col.Name}}() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte("{{$col.SqlName}} = :{{$col.Name}}"))
	return x
}
{{end}}

{{ if $tbl.GenEx }}
func (x *{{Title $tbl.Name}}NamedWhere) ModifyStamp() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}} = :modify_stamp"))
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) CreateStamp() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte("{{BackQuote "create_stamp"}} = :create_stamp"))
	return x
}
{{end}}

func (x *{{Title $tbl.Name}}NamedWhere) Limit(limit, offset int) *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) And() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte(" and "))
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) Or() *{{Title $tbl.Name}}NamedWhere {
	x.buf.Write([]byte(" or "))
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) Group(gf func(w *{{Title $tbl.Name}}NamedWhere)) *{{Title $tbl.Name}}NamedWhere {
	x.buf.WriteByte('(')
	gf(x)
	x.buf.WriteByte(')')
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) Custom(f func(buf *util.Builder)) *{{Title $tbl.Name}}NamedWhere {
	f(x.buf)
	return x
}

func (x *{{Title $tbl.Name}}NamedWhere) OnDuplicateKeyUpdate() *{{Title $tbl.Name}}NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := false 
	return &{{Title $tbl.Name}}NamedUpdate{
		buf: x.buf,
		n:   &v,
		values: &values,
	}
}


func (x *{{Title $tbl.Name}}NamedWhere) OnDuplicateKeyUpdateValues() *{{Title $tbl.Name}}NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := true
	return &{{Title $tbl.Name}}NamedUpdate{
		buf: x.buf,
		n:   &v,
		values: &values,
	}
}

func (x *{{Title $tbl.Name}}NamedWhere) ToSQL() string {
	return x.buf.String()
}

func (x *{{Title $tbl.Name}}NamedWhere) OrderBy() *{{Title $tbl.Name}}NamedOrderBy {
	x.buf.Write([]byte(" order by "))
	var v int
	return &{{Title $tbl.Name}}NamedOrderBy{
		buf: x.buf,
		n:   &v,
	}
}

type {{Title $tbl.Name}}NamedOrderBy struct {
	buf    *util.Builder
	n      *int
}

{{range $i,$col := $tbl.AllColumns false}}
func (x *{{Title $tbl.Name}}NamedOrderBy) {{Title $col.Name}}() *{{Title $tbl.Name}}NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{$col.SqlName}}"))
	*x.n++
	return &{{Title $tbl.Name}}NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}
{{end}}
{{ if $tbl.GenEx }}
func (x *{{Title $tbl.Name}}NamedOrderAsc) ModifyStamp() *{{Title $tbl.Name}}NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}}"))
	*x.n++
	return &{{Title $tbl.Name}}NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *{{Title $tbl.Name}}NamedOrderAsc) CreateStamp() *{{Title $tbl.Name}}NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "create_stamp"}}"))
	*x.n++
	return &{{Title $tbl.Name}}NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}
{{end}}

func (x *{{Title $tbl.Name}}NamedOrderBy) Limit(limit, offset int) *{{Title $tbl.Name}}NamedOrderBy {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *{{Title $tbl.Name}}NamedOrderBy) ToSQL() string {
	return x.buf.String()
}


type {{Title $tbl.Name}}NamedOrderAsc struct {
	buf    *util.Builder
	n      *int
}

func (x *{{Title $tbl.Name}}NamedOrderAsc) Asc() *{{Title $tbl.Name}}NamedOrderBy {
	x.buf.Write([]byte(" asc "))
	return &{{Title $tbl.Name}}NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *{{Title $tbl.Name}}NamedOrderAsc) Desc() *{{Title $tbl.Name}}NamedOrderBy {
	x.buf.Write([]byte(" desc "))
	return &{{Title $tbl.Name}}NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *{{Title $tbl.Name}}NamedOrderAsc) ToSQL() string {
	return x.buf.String()
}

`

const _indexBackup = `
{{if $tbl.Index }}
type {{Title $tbl.Name}}Index interface {
	Where() string
	Args() []interface{}
}
  {{- range $i,$idx := $tbl.Index }}
func {{Title $tbl.Name}}Index{{Title $idx.Name}}({{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} ) {{Title $tbl.Name}}Index {
	return &idx{{Title $tbl.Name}}{{Title $idx.Name}} { {{range $i,$col := $idx.Columns}}
		{{$col.Name}}:{{$col.Name}},{{end}}
	}
}
  {{- end}}
{{end}}


{{if $tbl.Index }}
func (t *x{{Title $tbl.Name}}Operation) FindByIndex(ctx context.Context, idx {{Title $tbl.Name}}Index) (datas []*{{Title $tbl.Struct}}, err error) {
	rows, err := t.db.QueryContext(ctx, {{Title $tbl.Name}}SQL_Find+idx.Where(), idx.Args()...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *x{{Title $tbl.Name}}Operation) FindExByIndex(ctx context.Context, idx {{Title $tbl.Name}}Index) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.db.QueryContext(ctx, {{Title $tbl.Name}}SQL_FindRow+idx.Where(), idx.Args()...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *x{{Title $tbl.Name}}Operation) CountByIndex(ctx context.Context, idx {{Title $tbl.Name}}Index) (count int, err error) {
	err = t.db.QueryRowContext(ctx, {{Title $tbl.Name}}SQL_Count+idx.Where(), idx.Args()...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index failed,%w", err)
	}
	return
}

func (t *x{{Title $tbl.Name}}Operation) DeleteByIndex(ctx context.Context, idx {{Title $tbl.Name}}Index) (res sql.Result, err error) {
	res, err = t.db.ExecContext(ctx, {{Title $tbl.Name}}SQL_Delete+idx.Where(), idx.Args()...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} cdelete_by_index failed,%w", err)
	}

	return
}
{{end}}

{{if $tbl.Index }}
////////////////////////////////////////////////////////////////////////////////
// index

{{- range $i,$idx := $tbl.Index }}
type idx{{Title $tbl.Name}}{{Title $idx.Name}} struct { {{range $i,$col := $idx.Columns}}
	{{$col.Name}} {{$col.GoType}} {{end}}
}

func (t *idx{{Title $tbl.Name}}{{Title $idx.Name}}) Where() string {
	return "where {{range $i,$col := $idx.Columns}}{{Comma $i}}{{$col.SqlName}}=?{{end}}"
}

func (t *idx{{Title $tbl.Name}}{{Title $idx.Name}}) Args() []interface{} {
	return []interface{}{ {{range $i,$col := $idx.Columns}}{{Comma $i}}t.{{$col.Name}} {{end}}}
}{{end}}
{{end}}

`

const _backupSql = `

func (t *x{{Title $tbl.Name}}Operation) ExecBySql(ctx context.Context, sql string) (sql.Result, error) {
	res, err := t.db.ExecContext(ctx, sql)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} exec_by_sql failed,%w", err)
	}
	return res, nil
}

func (t *x{{Title $tbl.Name}}Operation) QueryBySql(ctx context.Context, sql string) (datas []*{{Title $tbl.Struct}}, err error) {
	rows, err := t.db.QueryContext(ctx, sql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info query_by_sql failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *x{{Title $tbl.Name}}Operation) QueryExBySql(ctx context.Context, sql string) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.db.QueryContext(ctx, sql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info query_by_sql failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scan{{Title $tbl.Name}}Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

`
